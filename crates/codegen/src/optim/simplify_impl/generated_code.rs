// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - expr.isle
// - rules.isle

#![allow(dead_code, unreachable_code, unreachable_patterns)]
#![allow(unused_imports, unused_variables, non_snake_case, unused_mut)]
#![allow(irrefutable_let_patterns, unused_assignments, non_camel_case_types)]

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unpack_arg_array1(&mut self, arg0: &ArgArray1) -> ExprValue;
    fn pack_arg_array1(&mut self, arg0: ExprValue) -> ArgArray1;
    fn unpack_arg_array2(&mut self, arg0: &ArgArray2) -> (ExprValue, ExprValue);
    fn pack_arg_array2(&mut self, arg0: ExprValue, arg1: ExprValue) -> ArgArray2;
    fn expr_data(&mut self, arg0: Expr) -> ExprData;
    fn value_ty(&mut self, arg0: ExprValue) -> Type;
    fn value_expr(&mut self, arg0: ExprValue) -> Option<Expr>;
    fn is_zero(&mut self, arg0: ExprValue) -> bool;
    fn is_one(&mut self, arg0: ExprValue) -> bool;
    fn is_two(&mut self, arg0: ExprValue) -> bool;
    fn is_all_one(&mut self, arg0: ExprValue) -> bool;
    fn is_power_of_two(&mut self, arg0: ExprValue) -> bool;
    fn is_eq(&mut self, arg0: ExprValue, arg1: ExprValue) -> Option<Unit>;
    fn make_zero(&mut self, arg0: Type) -> ExprValue;
    fn make_one(&mut self, arg0: Type) -> ExprValue;
    fn make_true(&mut self) -> ExprValue;
    fn make_false(&mut self) -> ExprValue;
    fn make_all_one(&mut self, arg0: Type) -> ExprValue;
    fn make_result(&mut self, arg0: ExprValue) -> SimplifyRawResult;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

/// Internal type BrTableDefaultDest: defined at expr.isle line 14.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum BrTableDefaultDest {}

/// Internal type SimplifyRawResult: defined at rules.isle line 2.
#[derive(Clone, Debug)]
pub enum SimplifyRawResult {
    Value { val: ValueId },
    Expr { expr: ExprData },
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(ctx: &mut C, arg0: Expr) -> Option<SimplifyRawResult> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        if let &BinaryOp::Or = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                let pattern6_0 = C::expr_data(ctx, pattern5_0);
                if let &ExprData::Binary {
                    code: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &BinaryOp::And = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                        if let Some(pattern10_0) = C::value_expr(ctx, pattern9_1) {
                            let pattern11_0 = C::expr_data(ctx, pattern10_0);
                            if let &ExprData::Unary {
                                code: ref pattern12_0,
                                args: ref pattern12_1,
                            } = &pattern11_0
                            {
                                if let &UnaryOp::Not = pattern12_0 {
                                    let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                    if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                        let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                        if let &ExprData::Unary {
                                            code: ref pattern17_0,
                                            args: ref pattern17_1,
                                        } = &pattern16_0
                                        {
                                            if let &UnaryOp::Not = pattern17_0 {
                                                let pattern19_0 =
                                                    C::unpack_arg_array1(ctx, pattern17_1);
                                                if let Some(pattern20_0) =
                                                    C::value_expr(ctx, pattern19_0)
                                                {
                                                    let pattern21_0 =
                                                        C::expr_data(ctx, pattern20_0);
                                                    if let &ExprData::Binary {
                                                        code: ref pattern22_0,
                                                        args: ref pattern22_1,
                                                    } = &pattern21_0
                                                    {
                                                        if let &BinaryOp::Or = pattern22_0 {
                                                            let (pattern24_0, pattern24_1) =
                                                                C::unpack_arg_array2(
                                                                    ctx,
                                                                    pattern22_1,
                                                                );
                                                            let mut closure25 = || {
                                                                let expr0_0 = C::is_eq(
                                                                    ctx,
                                                                    pattern9_0,
                                                                    pattern24_1,
                                                                )?;
                                                                return Some(expr0_0);
                                                            };
                                                            if let Some(pattern25_0) = closure25() {
                                                                let mut closure26 = || {
                                                                    let expr0_0 = C::is_eq(
                                                                        ctx,
                                                                        pattern14_0,
                                                                        pattern24_0,
                                                                    )?;
                                                                    return Some(expr0_0);
                                                                };
                                                                if let Some(pattern26_0) =
                                                                    closure26()
                                                                {
                                                                    // Rule at rules.isle line 648.
                                                                    let expr0_0 = C::make_result(
                                                                        ctx, pattern9_1,
                                                                    );
                                                                    return Some(expr0_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        if let &BinaryOp::Or = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                let pattern6_0 = C::expr_data(ctx, pattern5_0);
                if let &ExprData::Binary {
                    code: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &BinaryOp::And = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                        if let Some(pattern10_0) = C::value_expr(ctx, pattern9_1) {
                            let pattern11_0 = C::expr_data(ctx, pattern10_0);
                            if let &ExprData::Unary {
                                code: ref pattern12_0,
                                args: ref pattern12_1,
                            } = &pattern11_0
                            {
                                if let &UnaryOp::Not = pattern12_0 {
                                    let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                    if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                        let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                        if let &ExprData::Unary {
                                            code: ref pattern17_0,
                                            args: ref pattern17_1,
                                        } = &pattern16_0
                                        {
                                            if let &UnaryOp::Not = pattern17_0 {
                                                let pattern19_0 =
                                                    C::unpack_arg_array1(ctx, pattern17_1);
                                                if let Some(pattern20_0) =
                                                    C::value_expr(ctx, pattern19_0)
                                                {
                                                    let pattern21_0 =
                                                        C::expr_data(ctx, pattern20_0);
                                                    if let &ExprData::Binary {
                                                        code: ref pattern22_0,
                                                        args: ref pattern22_1,
                                                    } = &pattern21_0
                                                    {
                                                        if let &BinaryOp::Or = pattern22_0 {
                                                            let (pattern24_0, pattern24_1) =
                                                                C::unpack_arg_array2(
                                                                    ctx,
                                                                    pattern22_1,
                                                                );
                                                            let mut closure25 = || {
                                                                let expr0_0 = C::is_eq(
                                                                    ctx,
                                                                    pattern9_0,
                                                                    pattern24_0,
                                                                )?;
                                                                return Some(expr0_0);
                                                            };
                                                            if let Some(pattern25_0) = closure25() {
                                                                let mut closure26 = || {
                                                                    let expr0_0 = C::is_eq(
                                                                        ctx,
                                                                        pattern14_0,
                                                                        pattern24_1,
                                                                    )?;
                                                                    return Some(expr0_0);
                                                                };
                                                                if let Some(pattern26_0) =
                                                                    closure26()
                                                                {
                                                                    // Rule at rules.isle line 636.
                                                                    let expr0_0 = C::make_result(
                                                                        ctx, pattern9_1,
                                                                    );
                                                                    return Some(expr0_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        if let &BinaryOp::Or = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                let pattern6_0 = C::expr_data(ctx, pattern5_0);
                if let &ExprData::Binary {
                    code: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &BinaryOp::And = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                        if let Some(pattern10_0) = C::value_expr(ctx, pattern9_0) {
                            let pattern11_0 = C::expr_data(ctx, pattern10_0);
                            if let &ExprData::Unary {
                                code: ref pattern12_0,
                                args: ref pattern12_1,
                            } = &pattern11_0
                            {
                                if let &UnaryOp::Not = pattern12_0 {
                                    let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                    if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                        let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                        if let &ExprData::Unary {
                                            code: ref pattern17_0,
                                            args: ref pattern17_1,
                                        } = &pattern16_0
                                        {
                                            if let &UnaryOp::Not = pattern17_0 {
                                                let pattern19_0 =
                                                    C::unpack_arg_array1(ctx, pattern17_1);
                                                if let Some(pattern20_0) =
                                                    C::value_expr(ctx, pattern19_0)
                                                {
                                                    let pattern21_0 =
                                                        C::expr_data(ctx, pattern20_0);
                                                    if let &ExprData::Binary {
                                                        code: ref pattern22_0,
                                                        args: ref pattern22_1,
                                                    } = &pattern21_0
                                                    {
                                                        if let &BinaryOp::Or = pattern22_0 {
                                                            let (pattern24_0, pattern24_1) =
                                                                C::unpack_arg_array2(
                                                                    ctx,
                                                                    pattern22_1,
                                                                );
                                                            let mut closure25 = || {
                                                                let expr0_0 = C::is_eq(
                                                                    ctx,
                                                                    pattern14_0,
                                                                    pattern24_1,
                                                                )?;
                                                                return Some(expr0_0);
                                                            };
                                                            if let Some(pattern25_0) = closure25() {
                                                                let mut closure26 = || {
                                                                    let expr0_0 = C::is_eq(
                                                                        ctx,
                                                                        pattern9_1,
                                                                        pattern24_0,
                                                                    )?;
                                                                    return Some(expr0_0);
                                                                };
                                                                if let Some(pattern26_0) =
                                                                    closure26()
                                                                {
                                                                    // Rule at rules.isle line 624.
                                                                    let expr0_0 = C::make_result(
                                                                        ctx, pattern9_0,
                                                                    );
                                                                    return Some(expr0_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        if let &BinaryOp::Or = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                let pattern6_0 = C::expr_data(ctx, pattern5_0);
                if let &ExprData::Binary {
                    code: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &BinaryOp::And = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                        if let Some(pattern10_0) = C::value_expr(ctx, pattern9_0) {
                            let pattern11_0 = C::expr_data(ctx, pattern10_0);
                            if let &ExprData::Unary {
                                code: ref pattern12_0,
                                args: ref pattern12_1,
                            } = &pattern11_0
                            {
                                if let &UnaryOp::Not = pattern12_0 {
                                    let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                    if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                        let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                        if let &ExprData::Unary {
                                            code: ref pattern17_0,
                                            args: ref pattern17_1,
                                        } = &pattern16_0
                                        {
                                            if let &UnaryOp::Not = pattern17_0 {
                                                let pattern19_0 =
                                                    C::unpack_arg_array1(ctx, pattern17_1);
                                                if let Some(pattern20_0) =
                                                    C::value_expr(ctx, pattern19_0)
                                                {
                                                    let pattern21_0 =
                                                        C::expr_data(ctx, pattern20_0);
                                                    if let &ExprData::Binary {
                                                        code: ref pattern22_0,
                                                        args: ref pattern22_1,
                                                    } = &pattern21_0
                                                    {
                                                        if let &BinaryOp::Or = pattern22_0 {
                                                            let (pattern24_0, pattern24_1) =
                                                                C::unpack_arg_array2(
                                                                    ctx,
                                                                    pattern22_1,
                                                                );
                                                            let mut closure25 = || {
                                                                let expr0_0 = C::is_eq(
                                                                    ctx,
                                                                    pattern14_0,
                                                                    pattern24_0,
                                                                )?;
                                                                return Some(expr0_0);
                                                            };
                                                            if let Some(pattern25_0) = closure25() {
                                                                let mut closure26 = || {
                                                                    let expr0_0 = C::is_eq(
                                                                        ctx,
                                                                        pattern9_1,
                                                                        pattern24_1,
                                                                    )?;
                                                                    return Some(expr0_0);
                                                                };
                                                                if let Some(pattern26_0) =
                                                                    closure26()
                                                                {
                                                                    // Rule at rules.isle line 612.
                                                                    let expr0_0 = C::make_result(
                                                                        ctx, pattern9_0,
                                                                    );
                                                                    return Some(expr0_0);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        if let &BinaryOp::Or = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                let pattern6_0 = C::expr_data(ctx, pattern5_0);
                if let &ExprData::Binary {
                    code: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &BinaryOp::Or = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                        if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                            let pattern11_0 = C::expr_data(ctx, pattern10_0);
                            if let &ExprData::Binary {
                                code: ref pattern12_0,
                                args: ref pattern12_1,
                            } = &pattern11_0
                            {
                                if let &BinaryOp::Xor = pattern12_0 {
                                    let (pattern14_0, pattern14_1) =
                                        C::unpack_arg_array2(ctx, pattern12_1);
                                    let mut closure15 = || {
                                        let expr0_0 = C::is_eq(ctx, pattern9_0, pattern14_1)?;
                                        return Some(expr0_0);
                                    };
                                    if let Some(pattern15_0) = closure15() {
                                        let mut closure16 = || {
                                            let expr0_0 = C::is_eq(ctx, pattern9_1, pattern14_0)?;
                                            return Some(expr0_0);
                                        };
                                        if let Some(pattern16_0) = closure16() {
                                            // Rule at rules.isle line 599.
                                            let expr0_0 = C::make_result(ctx, pattern4_0);
                                            return Some(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        if let &BinaryOp::Or = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
            if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                let pattern6_0 = C::expr_data(ctx, pattern5_0);
                if let &ExprData::Binary {
                    code: ref pattern7_0,
                    args: ref pattern7_1,
                } = &pattern6_0
                {
                    if let &BinaryOp::Or = pattern7_0 {
                        let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                        if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                            let pattern11_0 = C::expr_data(ctx, pattern10_0);
                            if let &ExprData::Binary {
                                code: ref pattern12_0,
                                args: ref pattern12_1,
                            } = &pattern11_0
                            {
                                if let &BinaryOp::Xor = pattern12_0 {
                                    let (pattern14_0, pattern14_1) =
                                        C::unpack_arg_array2(ctx, pattern12_1);
                                    let mut closure15 = || {
                                        let expr0_0 = C::is_eq(ctx, pattern9_0, pattern14_0)?;
                                        return Some(expr0_0);
                                    };
                                    if let Some(pattern15_0) = closure15() {
                                        let mut closure16 = || {
                                            let expr0_0 = C::is_eq(ctx, pattern9_1, pattern14_1)?;
                                            return Some(expr0_0);
                                        };
                                        if let Some(pattern16_0) = closure16() {
                                            // Rule at rules.isle line 586.
                                            let expr0_0 = C::make_result(ctx, pattern4_0);
                                            return Some(expr0_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern9_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Unary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &UnaryOp::Not = pattern12_0 {
                                        let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Binary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &BinaryOp::And = pattern17_0 {
                                                    let (pattern19_0, pattern19_1) =
                                                        C::unpack_arg_array2(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_1)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern14_0,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 573.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::And = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_1)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 785.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern14_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern9_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Unary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &UnaryOp::Not = pattern12_0 {
                                        let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Binary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &BinaryOp::And = pattern17_0 {
                                                    let (pattern19_0, pattern19_1) =
                                                        C::unpack_arg_array2(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern14_0,
                                                                pattern19_1,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 560.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::And = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 773.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern14_1);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Sub = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let pattern10_0 = C::is_power_of_two(ctx, pattern9_0);
                            if pattern10_0 == true {
                                let pattern12_0 = C::value_ty(ctx, pattern9_0);
                                let pattern13_0 = C::is_one(ctx, pattern9_1);
                                if pattern13_0 == true {
                                    let mut closure15 = || {
                                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                        return Some(expr0_0);
                                    };
                                    if let Some(pattern15_0) = closure15() {
                                        // Rule at rules.isle line 411.
                                        let expr0_0 = C::make_zero(ctx, pattern12_0);
                                        let expr1_0 = C::make_result(ctx, expr0_0);
                                        return Some(expr1_0);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern9_0) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Unary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &UnaryOp::Not = pattern12_0 {
                                        let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Binary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &BinaryOp::And = pattern17_0 {
                                                    let (pattern19_0, pattern19_1) =
                                                        C::unpack_arg_array2(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 = C::is_eq(
                                                            ctx,
                                                            pattern14_0,
                                                            pattern19_1,
                                                        )?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 547.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::And = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 761.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern14_1);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Unary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &UnaryOp::Neg = pattern7_0 {
                            let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                            let pattern10_0 = C::is_power_of_two(ctx, pattern9_0);
                            if pattern10_0 == true {
                                let mut closure12 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern12_0) = closure12() {
                                    // Rule at rules.isle line 403.
                                    let expr0_0 = C::make_result(ctx, pattern4_0);
                                    return Some(expr0_0);
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern9_0) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Unary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &UnaryOp::Not = pattern12_0 {
                                        let pattern14_0 = C::unpack_arg_array1(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern4_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Binary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &BinaryOp::And = pattern17_0 {
                                                    let (pattern19_0, pattern19_1) =
                                                        C::unpack_arg_array2(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 = C::is_eq(
                                                            ctx,
                                                            pattern14_0,
                                                            pattern19_0,
                                                        )?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_1,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 535.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::And = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_1,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 749.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern14_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 389.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_1);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 522.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_1)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 737.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_1);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_1,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 376.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_1);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_1,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 509.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 725.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_1);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Sub => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Add = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let mut closure10 = || {
                                let expr0_0 = C::is_eq(ctx, pattern9_1, pattern4_1)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern10_0) = closure10() {
                                // Rule at rules.isle line 158.
                                let expr0_0 = C::make_result(ctx, pattern9_0);
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_1)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 364.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_1)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 496.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 713.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Sub => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Add = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let mut closure10 = || {
                                let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_1)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern10_0) = closure10() {
                                // Rule at rules.isle line 150.
                                let expr0_0 = UnaryOp::Neg;
                                let expr1_0 = C::pack_arg_array1(ctx, pattern9_0);
                                let expr2_0 = ExprData::Unary {
                                    code: expr0_0,
                                    args: expr1_0,
                                };
                                let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                return Some(expr3_0);
                            }
                        }
                    }
                }
            }
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::Or = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 352.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_1) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern14_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern19_0,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 483.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern4_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Unary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &UnaryOp::Not = pattern7_0 {
                            let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern9_0) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        let pattern15_0 = C::value_ty(ctx, pattern14_1);
                                        let mut closure16 = || {
                                            let expr0_0 = C::is_eq(ctx, pattern4_0, pattern14_1)?;
                                            return Some(expr0_0);
                                        };
                                        if let Some(pattern16_0) = closure16() {
                                            // Rule at rules.isle line 475.
                                            let expr0_0 = C::make_all_one(ctx, pattern15_0);
                                            let expr1_0 = C::make_result(ctx, expr0_0);
                                            return Some(expr1_0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            if let Some(pattern10_0) = C::value_expr(ctx, pattern4_1) {
                                let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                if let &ExprData::Binary {
                                    code: ref pattern12_0,
                                    args: ref pattern12_1,
                                } = &pattern11_0
                                {
                                    if let &BinaryOp::And = pattern12_0 {
                                        let (pattern14_0, pattern14_1) =
                                            C::unpack_arg_array2(ctx, pattern12_1);
                                        if let Some(pattern15_0) = C::value_expr(ctx, pattern14_0) {
                                            let pattern16_0 = C::expr_data(ctx, pattern15_0);
                                            if let &ExprData::Unary {
                                                code: ref pattern17_0,
                                                args: ref pattern17_1,
                                            } = &pattern16_0
                                            {
                                                if let &UnaryOp::Not = pattern17_0 {
                                                    let pattern19_0 =
                                                        C::unpack_arg_array1(ctx, pattern17_1);
                                                    let mut closure20 = || {
                                                        let expr0_0 =
                                                            C::is_eq(ctx, pattern9_0, pattern19_0)?;
                                                        return Some(expr0_0);
                                                    };
                                                    if let Some(pattern20_0) = closure20() {
                                                        let mut closure21 = || {
                                                            let expr0_0 = C::is_eq(
                                                                ctx,
                                                                pattern9_1,
                                                                pattern14_1,
                                                            )?;
                                                            return Some(expr0_0);
                                                        };
                                                        if let Some(pattern21_0) = closure21() {
                                                            // Rule at rules.isle line 701.
                                                            let expr0_0 =
                                                                C::make_result(ctx, pattern9_0);
                                                            return Some(expr0_0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Sub => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        match pattern7_0 {
                            &BinaryOp::Add => {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern9_0, pattern4_1)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 142.
                                    let expr0_0 = C::make_result(ctx, pattern9_1);
                                    return Some(expr0_0);
                                }
                            }
                            &BinaryOp::Sub => {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern9_0, pattern4_1)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 134.
                                    let expr0_0 = UnaryOp::Neg;
                                    let expr1_0 = C::pack_arg_array1(ctx, pattern9_1);
                                    let expr2_0 = ExprData::Unary {
                                        code: expr0_0,
                                        args: expr1_0,
                                    };
                                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                    return Some(expr3_0);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Or = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let mut closure10 = || {
                                let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_1)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern10_0) = closure10() {
                                // Rule at rules.isle line 344.
                                let expr0_0 = C::make_result(ctx, pattern4_0);
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    match &pattern6_0 {
                        &ExprData::Unary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &UnaryOp::Not = pattern7_0 {
                                let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                if let Some(pattern10_0) = C::value_expr(ctx, pattern9_0) {
                                    let pattern11_0 = C::expr_data(ctx, pattern10_0);
                                    if let &ExprData::Binary {
                                        code: ref pattern12_0,
                                        args: ref pattern12_1,
                                    } = &pattern11_0
                                    {
                                        if let &BinaryOp::And = pattern12_0 {
                                            let (pattern14_0, pattern14_1) =
                                                C::unpack_arg_array2(ctx, pattern12_1);
                                            let pattern15_0 = C::value_ty(ctx, pattern14_0);
                                            let mut closure16 = || {
                                                let expr0_0 =
                                                    C::is_eq(ctx, pattern4_0, pattern14_0)?;
                                                return Some(expr0_0);
                                            };
                                            if let Some(pattern16_0) = closure16() {
                                                // Rule at rules.isle line 467.
                                                let expr0_0 = C::make_all_one(ctx, pattern15_0);
                                                let expr1_0 = C::make_result(ctx, expr0_0);
                                                return Some(expr1_0);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &ExprData::Binary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &BinaryOp::And = pattern7_0 {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_1)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 459.
                                    let expr0_0 = C::make_result(ctx, pattern4_0);
                                    return Some(expr0_0);
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let mut closure10 = || {
                                let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_1)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern10_0) = closure10() {
                                // Rule at rules.isle line 693.
                                let expr0_0 = C::make_result(ctx, pattern9_0);
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Sub => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        match pattern7_0 {
                            &BinaryOp::Add => {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 126.
                                    let expr0_0 = UnaryOp::Neg;
                                    let expr1_0 = C::pack_arg_array1(ctx, pattern9_1);
                                    let expr2_0 = ExprData::Unary {
                                        code: expr0_0,
                                        args: expr1_0,
                                    };
                                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                    return Some(expr3_0);
                                }
                            }
                            &BinaryOp::Sub => {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 118.
                                    let expr0_0 = C::make_result(ctx, pattern9_1);
                                    return Some(expr0_0);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    match &pattern6_0 {
                        &ExprData::Unary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &UnaryOp::Not = pattern7_0 {
                                let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                let pattern10_0 = C::value_ty(ctx, pattern9_0);
                                let mut closure11 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern11_0) = closure11() {
                                    // Rule at rules.isle line 328.
                                    let expr0_0 = C::make_zero(ctx, pattern10_0);
                                    let expr1_0 = C::make_result(ctx, expr0_0);
                                    return Some(expr1_0);
                                }
                            }
                        }
                        &ExprData::Binary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &BinaryOp::Or = pattern7_0 {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 336.
                                    let expr0_0 = C::make_result(ctx, pattern4_0);
                                    return Some(expr0_0);
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    match &pattern6_0 {
                        &ExprData::Unary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &UnaryOp::Not = pattern7_0 {
                                let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                let pattern10_0 = C::value_ty(ctx, pattern9_0);
                                let mut closure11 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern11_0) = closure11() {
                                    // Rule at rules.isle line 443.
                                    let expr0_0 = C::make_all_one(ctx, pattern10_0);
                                    let expr1_0 = C::make_result(ctx, expr0_0);
                                    return Some(expr1_0);
                                }
                            }
                        }
                        &ExprData::Binary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &BinaryOp::And = pattern7_0 {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 451.
                                    let expr0_0 = C::make_result(ctx, pattern4_0);
                                    return Some(expr0_0);
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Xor = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let mut closure10 = || {
                                let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern10_0) = closure10() {
                                // Rule at rules.isle line 685.
                                let expr0_0 = C::make_result(ctx, pattern9_1);
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Add => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Binary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &BinaryOp::Sub = pattern7_0 {
                            let (pattern9_0, pattern9_1) = C::unpack_arg_array2(ctx, pattern7_1);
                            let mut closure10 = || {
                                let expr0_0 = C::is_eq(ctx, pattern9_0, pattern4_1)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern10_0) = closure10() {
                                // Rule at rules.isle line 86.
                                let expr0_0 = C::make_result(ctx, pattern9_0);
                                return Some(expr0_0);
                            }
                        }
                    }
                }
            }
            &BinaryOp::Sub => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::is_zero(ctx, pattern4_0);
                if pattern5_0 == true {
                    // Rule at rules.isle line 111.
                    let expr0_0 = UnaryOp::Neg;
                    let expr1_0 = C::pack_arg_array1(ctx, pattern4_1);
                    let expr2_0 = ExprData::Unary {
                        code: expr0_0,
                        args: expr1_0,
                    };
                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                    return Some(expr3_0);
                }
            }
            &BinaryOp::Mul => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::is_two(ctx, pattern4_1);
                if pattern5_0 == true {
                    // Rule at rules.isle line 182.
                    let expr0_0 = BinaryOp::Add;
                    let expr1_0 = C::pack_arg_array2(ctx, pattern4_0, pattern4_0);
                    let expr2_0 = ExprData::Binary {
                        code: expr0_0,
                        args: expr1_0,
                    };
                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                    return Some(expr3_0);
                }
            }
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let mut closure5 = || {
                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                    return Some(expr0_0);
                };
                if let Some(pattern5_0) = closure5() {
                    // Rule at rules.isle line 320.
                    let expr0_0 = C::make_result(ctx, pattern4_0);
                    return Some(expr0_0);
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::is_zero(ctx, pattern4_1);
                if pattern5_0 == true {
                    // Rule at rules.isle line 436.
                    let expr0_0 = C::make_result(ctx, pattern4_0);
                    return Some(expr0_0);
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    if let &ExprData::Unary {
                        code: ref pattern7_0,
                        args: ref pattern7_1,
                    } = &pattern6_0
                    {
                        if let &UnaryOp::Not = pattern7_0 {
                            let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                            let pattern10_0 = C::value_ty(ctx, pattern4_1);
                            let mut closure11 = || {
                                let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                return Some(expr0_0);
                            };
                            if let Some(pattern11_0) = closure11() {
                                // Rule at rules.isle line 677.
                                let expr0_0 = C::make_all_one(ctx, pattern10_0);
                                let expr1_0 = C::make_result(ctx, expr0_0);
                                return Some(expr1_0);
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    if let &ExprData::Binary {
        code: ref pattern2_0,
        args: ref pattern2_1,
    } = &pattern1_0
    {
        match pattern2_0 {
            &BinaryOp::Add => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                if let Some(pattern5_0) = C::value_expr(ctx, pattern4_1) {
                    let pattern6_0 = C::expr_data(ctx, pattern5_0);
                    match &pattern6_0 {
                        &ExprData::Unary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            match pattern7_0 {
                                &UnaryOp::Not => {
                                    let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                    let pattern10_0 = C::value_ty(ctx, pattern9_0);
                                    let mut closure11 = || {
                                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                        return Some(expr0_0);
                                    };
                                    if let Some(pattern11_0) = closure11() {
                                        // Rule at rules.isle line 78.
                                        let expr0_0 = C::make_all_one(ctx, pattern10_0);
                                        let expr1_0 = C::make_result(ctx, expr0_0);
                                        return Some(expr1_0);
                                    }
                                }
                                &UnaryOp::Neg => {
                                    let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                    let pattern10_0 = C::value_ty(ctx, pattern9_0);
                                    let mut closure11 = || {
                                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_0)?;
                                        return Some(expr0_0);
                                    };
                                    if let Some(pattern11_0) = closure11() {
                                        // Rule at rules.isle line 62.
                                        let expr0_0 = C::make_zero(ctx, pattern10_0);
                                        let expr1_0 = C::make_result(ctx, expr0_0);
                                        return Some(expr1_0);
                                    }
                                }
                                _ => {}
                            }
                        }
                        &ExprData::Binary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } => {
                            if let &BinaryOp::Sub = pattern7_0 {
                                let (pattern9_0, pattern9_1) =
                                    C::unpack_arg_array2(ctx, pattern7_1);
                                let mut closure10 = || {
                                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern9_1)?;
                                    return Some(expr0_0);
                                };
                                if let Some(pattern10_0) = closure10() {
                                    // Rule at rules.isle line 70.
                                    let expr0_0 = C::make_result(ctx, pattern9_0);
                                    return Some(expr0_0);
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
            &BinaryOp::Sub => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::is_zero(ctx, pattern4_1);
                if pattern5_0 == true {
                    // Rule at rules.isle line 104.
                    let expr0_0 = C::make_result(ctx, pattern4_0);
                    return Some(expr0_0);
                }
            }
            &BinaryOp::Mul => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::is_one(ctx, pattern4_1);
                if pattern5_0 == true {
                    // Rule at rules.isle line 175.
                    let expr0_0 = C::make_result(ctx, pattern4_0);
                    return Some(expr0_0);
                }
            }
            &BinaryOp::And => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::is_all_one(ctx, pattern4_1);
                if pattern5_0 == true {
                    // Rule at rules.isle line 313.
                    let expr0_0 = C::make_result(ctx, pattern4_0);
                    return Some(expr0_0);
                }
            }
            &BinaryOp::Or => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let mut closure5 = || {
                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                    return Some(expr0_0);
                };
                if let Some(pattern5_0) = closure5() {
                    // Rule at rules.isle line 428.
                    let expr0_0 = C::make_result(ctx, pattern4_0);
                    return Some(expr0_0);
                }
            }
            &BinaryOp::Xor => {
                let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                let pattern5_0 = C::value_ty(ctx, pattern4_1);
                let mut closure6 = || {
                    let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                    return Some(expr0_0);
                };
                if let Some(pattern6_0) = closure6() {
                    // Rule at rules.isle line 669.
                    let expr0_0 = C::make_zero(ctx, pattern5_0);
                    let expr1_0 = C::make_result(ctx, expr0_0);
                    return Some(expr1_0);
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::expr_data(ctx, pattern0_0);
    match &pattern1_0 {
        &ExprData::Unary {
            code: ref pattern2_0,
            args: ref pattern2_1,
        } => {
            match pattern2_0 {
                &UnaryOp::Not => {
                    let pattern4_0 = C::unpack_arg_array1(ctx, pattern2_1);
                    if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                        let pattern6_0 = C::expr_data(ctx, pattern5_0);
                        match &pattern6_0 {
                            &ExprData::Unary {
                                code: ref pattern7_0,
                                args: ref pattern7_1,
                            } => {
                                match pattern7_0 {
                                    &UnaryOp::Not => {
                                        let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                        // Rule at rules.isle line 800.
                                        let expr0_0 = C::make_result(ctx, pattern9_0);
                                        return Some(expr0_0);
                                    }
                                    &UnaryOp::Neg => {
                                        let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                        let pattern10_0 = C::value_ty(ctx, pattern9_0);
                                        // Rule at rules.isle line 807.
                                        let expr0_0 = BinaryOp::Sub;
                                        let expr1_0 = C::make_one(ctx, pattern10_0);
                                        let expr2_0 = C::pack_arg_array2(ctx, pattern9_0, expr1_0);
                                        let expr3_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr2_0,
                                        };
                                        let expr4_0 = SimplifyRawResult::Expr { expr: expr3_0 };
                                        return Some(expr4_0);
                                    }
                                    _ => {}
                                }
                            }
                            &ExprData::Binary {
                                code: ref pattern7_0,
                                args: ref pattern7_1,
                            } => {
                                match pattern7_0 {
                                    &BinaryOp::Lt => {
                                        let (pattern9_0, pattern9_1) =
                                            C::unpack_arg_array2(ctx, pattern7_1);
                                        // Rule at rules.isle line 828.
                                        let expr0_0 = BinaryOp::Le;
                                        let expr1_0 =
                                            C::pack_arg_array2(ctx, pattern9_1, pattern9_0);
                                        let expr2_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr1_0,
                                        };
                                        let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                        return Some(expr3_0);
                                    }
                                    &BinaryOp::Slt => {
                                        let (pattern9_0, pattern9_1) =
                                            C::unpack_arg_array2(ctx, pattern7_1);
                                        // Rule at rules.isle line 842.
                                        let expr0_0 = BinaryOp::Sle;
                                        let expr1_0 =
                                            C::pack_arg_array2(ctx, pattern9_1, pattern9_0);
                                        let expr2_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr1_0,
                                        };
                                        let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                        return Some(expr3_0);
                                    }
                                    &BinaryOp::Le => {
                                        let (pattern9_0, pattern9_1) =
                                            C::unpack_arg_array2(ctx, pattern7_1);
                                        // Rule at rules.isle line 835.
                                        let expr0_0 = BinaryOp::Lt;
                                        let expr1_0 =
                                            C::pack_arg_array2(ctx, pattern9_1, pattern9_0);
                                        let expr2_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr1_0,
                                        };
                                        let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                        return Some(expr3_0);
                                    }
                                    &BinaryOp::Sle => {
                                        let (pattern9_0, pattern9_1) =
                                            C::unpack_arg_array2(ctx, pattern7_1);
                                        // Rule at rules.isle line 849.
                                        let expr0_0 = BinaryOp::Slt;
                                        let expr1_0 =
                                            C::pack_arg_array2(ctx, pattern9_1, pattern9_0);
                                        let expr2_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr1_0,
                                        };
                                        let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                        return Some(expr3_0);
                                    }
                                    &BinaryOp::Eq => {
                                        let (pattern9_0, pattern9_1) =
                                            C::unpack_arg_array2(ctx, pattern7_1);
                                        // Rule at rules.isle line 814.
                                        let expr0_0 = BinaryOp::Ne;
                                        let expr1_0 =
                                            C::pack_arg_array2(ctx, pattern9_0, pattern9_1);
                                        let expr2_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr1_0,
                                        };
                                        let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                        return Some(expr3_0);
                                    }
                                    &BinaryOp::Ne => {
                                        let (pattern9_0, pattern9_1) =
                                            C::unpack_arg_array2(ctx, pattern7_1);
                                        // Rule at rules.isle line 821.
                                        let expr0_0 = BinaryOp::Eq;
                                        let expr1_0 =
                                            C::pack_arg_array2(ctx, pattern9_0, pattern9_1);
                                        let expr2_0 = ExprData::Binary {
                                            code: expr0_0,
                                            args: expr1_0,
                                        };
                                        let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                                        return Some(expr3_0);
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &UnaryOp::Neg => {
                    let pattern4_0 = C::unpack_arg_array1(ctx, pattern2_1);
                    if let Some(pattern5_0) = C::value_expr(ctx, pattern4_0) {
                        let pattern6_0 = C::expr_data(ctx, pattern5_0);
                        if let &ExprData::Unary {
                            code: ref pattern7_0,
                            args: ref pattern7_1,
                        } = &pattern6_0
                        {
                            match pattern7_0 {
                                &UnaryOp::Not => {
                                    let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                    let pattern10_0 = C::value_ty(ctx, pattern9_0);
                                    // Rule at rules.isle line 865.
                                    let expr0_0 = BinaryOp::Add;
                                    let expr1_0 = C::make_one(ctx, pattern10_0);
                                    let expr2_0 = C::pack_arg_array2(ctx, pattern9_0, expr1_0);
                                    let expr3_0 = ExprData::Binary {
                                        code: expr0_0,
                                        args: expr2_0,
                                    };
                                    let expr4_0 = SimplifyRawResult::Expr { expr: expr3_0 };
                                    return Some(expr4_0);
                                }
                                &UnaryOp::Neg => {
                                    let pattern9_0 = C::unpack_arg_array1(ctx, pattern7_1);
                                    // Rule at rules.isle line 858.
                                    let expr0_0 = C::make_result(ctx, pattern9_0);
                                    return Some(expr0_0);
                                }
                                _ => {}
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        &ExprData::Binary {
            code: ref pattern2_0,
            args: ref pattern2_1,
        } => {
            match pattern2_0 {
                &BinaryOp::Add => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_zero(ctx, pattern4_1);
                    if pattern5_0 == true {
                        // Rule at rules.isle line 57.
                        let expr0_0 = C::make_result(ctx, pattern4_0);
                        return Some(expr0_0);
                    }
                }
                &BinaryOp::Sub => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::value_ty(ctx, pattern4_1);
                    let mut closure6 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern6_0) = closure6() {
                        // Rule at rules.isle line 97.
                        let expr0_0 = C::make_zero(ctx, pattern5_0);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Mul => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_zero(ctx, pattern4_1);
                    if pattern5_0 == true {
                        let pattern7_0 = C::value_ty(ctx, pattern4_1);
                        // Rule at rules.isle line 169.
                        let expr0_0 = C::make_zero(ctx, pattern7_0);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Udiv => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_zero(ctx, pattern4_0);
                    if pattern5_0 == true {
                        let pattern7_0 = C::value_ty(ctx, pattern4_0);
                        // Rule at rules.isle line 201.
                        let expr0_0 = C::make_zero(ctx, pattern7_0);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Sdiv => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_zero(ctx, pattern4_0);
                    if pattern5_0 == true {
                        let pattern7_0 = C::value_ty(ctx, pattern4_0);
                        // Rule at rules.isle line 192.
                        let expr0_0 = C::make_zero(ctx, pattern7_0);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Lt => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let mut closure5 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern5_0) = closure5() {
                        // Rule at rules.isle line 231.
                        let expr0_0 = C::make_false(ctx);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Gt => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    // Rule at rules.isle line 241.
                    let expr0_0 = BinaryOp::Lt;
                    let expr1_0 = C::pack_arg_array2(ctx, pattern4_1, pattern4_0);
                    let expr2_0 = ExprData::Binary {
                        code: expr0_0,
                        args: expr1_0,
                    };
                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                    return Some(expr3_0);
                }
                &BinaryOp::Slt => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let mut closure5 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern5_0) = closure5() {
                        // Rule at rules.isle line 250.
                        let expr0_0 = C::make_false(ctx);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Sgt => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    // Rule at rules.isle line 260.
                    let expr0_0 = BinaryOp::Slt;
                    let expr1_0 = C::pack_arg_array2(ctx, pattern4_1, pattern4_0);
                    let expr2_0 = ExprData::Binary {
                        code: expr0_0,
                        args: expr1_0,
                    };
                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                    return Some(expr3_0);
                }
                &BinaryOp::Le => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let mut closure5 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern5_0) = closure5() {
                        // Rule at rules.isle line 269.
                        let expr0_0 = C::make_true(ctx);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Ge => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    // Rule at rules.isle line 279.
                    let expr0_0 = BinaryOp::Le;
                    let expr1_0 = C::pack_arg_array2(ctx, pattern4_1, pattern4_0);
                    let expr2_0 = ExprData::Binary {
                        code: expr0_0,
                        args: expr1_0,
                    };
                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                    return Some(expr3_0);
                }
                &BinaryOp::Sle => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let mut closure5 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern5_0) = closure5() {
                        // Rule at rules.isle line 288.
                        let expr0_0 = C::make_true(ctx);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Sge => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    // Rule at rules.isle line 298.
                    let expr0_0 = BinaryOp::Sle;
                    let expr1_0 = C::pack_arg_array2(ctx, pattern4_1, pattern4_0);
                    let expr2_0 = ExprData::Binary {
                        code: expr0_0,
                        args: expr1_0,
                    };
                    let expr3_0 = SimplifyRawResult::Expr { expr: expr2_0 };
                    return Some(expr3_0);
                }
                &BinaryOp::Eq => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let mut closure5 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern5_0) = closure5() {
                        // Rule at rules.isle line 210.
                        let expr0_0 = C::make_true(ctx);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Ne => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let mut closure5 = || {
                        let expr0_0 = C::is_eq(ctx, pattern4_0, pattern4_1)?;
                        return Some(expr0_0);
                    };
                    if let Some(pattern5_0) = closure5() {
                        // Rule at rules.isle line 220.
                        let expr0_0 = C::make_false(ctx);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::And => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_zero(ctx, pattern4_1);
                    if pattern5_0 == true {
                        let pattern7_0 = C::value_ty(ctx, pattern4_1);
                        // Rule at rules.isle line 307.
                        let expr0_0 = C::make_zero(ctx, pattern7_0);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Or => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_all_one(ctx, pattern4_1);
                    if pattern5_0 == true {
                        let pattern7_0 = C::value_ty(ctx, pattern4_1);
                        // Rule at rules.isle line 422.
                        let expr0_0 = C::make_all_one(ctx, pattern7_0);
                        let expr1_0 = C::make_result(ctx, expr0_0);
                        return Some(expr1_0);
                    }
                }
                &BinaryOp::Xor => {
                    let (pattern4_0, pattern4_1) = C::unpack_arg_array2(ctx, pattern2_1);
                    let pattern5_0 = C::is_zero(ctx, pattern4_1);
                    if pattern5_0 == true {
                        // Rule at rules.isle line 663.
                        let expr0_0 = C::make_result(ctx, pattern4_0);
                        return Some(expr0_0);
                    }
                }
                _ => {}
            }
        }
        _ => {}
    }
    return None;
}
