# check: block6:
# nextln: v74.i8 = phi (v32 block3) (v42 block4)
# nextln: v73.i8 = phi (v31 block3) (v41 block4)
# nextln: v60.i8 = phi (v30 block3) (v40 block4)
# nextln: jump block7;
# check: block7:
# nextln: v75.i8 = phi (v52 block5) (v74 block6)
# nextln: v70.i8 = phi (v73 block6) (v50 block5)
# nextln: return v75;
func %recursive_phi_value(v0.i8, v1.i8) -> i8:
    block0:
        br v0 block1 block2;

    block1:
        br v0 block3 block4;

    block2:
        jump block5;

    block3:
        v30.i8 = imm_i8 3;
        v31.i8 = add v30 v0;
        v32.i8 = add v31 v1;
        jump block6;

    block4:
        v40.i8 = imm_i8 4;
        v41.i8 = add v40 v0;
        v42.i8 = add v41 v1;
        jump block6;

    block5:
        v50.i8 = imm_i8 5;
        v52.i8 = add v50 v1;
        jump block7;

    block6:
        v60.i8 = phi (v30 block3) (v40 block4);
        v61.i8 = add v60 v0;
        jump block7;

    block7:
        v70.i8 = phi (v61 block6) (v50 block5);
        v72.i8 = add v70 v1;
        return v72;
