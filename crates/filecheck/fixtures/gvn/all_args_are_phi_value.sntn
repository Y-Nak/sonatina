# check:  block6:
# nextln:     v73.i8 = phi (v32 block3) (v42 block4);
# nextln:     v60.i8 = phi (v30 block3) (v40 block4);
# nextln:     v61.i8 = phi (v31 block3) (v41 block4);
# nextln:     jump block7;
# nextln: 
# nextln: block7:
# nextln:     v74.i8 = phi (v52 block5) (v73 block6);
# nextln:     v70.i8 = phi (v50 block5) (v60 block6);
# nextln:     v71.i8 = phi (v51 block5) (v61 block6);
# nextln:     return v74;
func %recursive_phi_value(v0.i8) -> i8:
    block0:
        br v0 block1 block2;

    block1:
        br v0 block3 block4;

    block2:
        jump block5;

    block3:
        v30.i8 = imm_i8 30;
        v31.i8 = imm_i8 31;
        v32.i8 = add v30 v31;
        jump block6;

    block4:
        v40.i8 = imm_i8 40;
        v41.i8 = imm_i8 41;
        v42.i8 = add v40 v41;
        jump block6;

    block5:
        v50.i8 = imm_i8 50;
        v51.i8 = imm_i8 51;
        v52.i8 = add v50 v51;
        jump block7;

    block6:
        v60.i8 = phi (v30 block3) (v40 block4);
        v61.i8 = phi (v31 block3) (v41 block4);
        jump block7;

    block7:
        v70.i8 = phi (v50 block5) (v60 block6);
        v71.i8 = phi (v51 block5) (v61 block6);
        v72.i8 = add v70 v71;
        return v72;
